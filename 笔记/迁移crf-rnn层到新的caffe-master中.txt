1.需要依赖工具，util/modified_permutohedral.cpp和util/modified_permutohedral.hpp，直接复制粘贴即可
2.迁移层，meanfield_iteration和multi_stage_meanfield。头文件定义在vision_layers.hpp中，需要单独抠出来
3.cpp文件拷贝后，对multi_stage_meanfield进行修改：
line 64附近，原实现需要对spatial.par和bilateral.par进行文件读取，可以讲初始化参数的读入改为通过proto参数传递实现：
    FILE * pFile;
    pFile = fopen("spatial.par", "r");
    CHECK(pFile) << "The file 'spatial.par' is not found. Please create it with initial spatial kernel weights.";
    for (int i = 0; i < channels_; i++) {
      fscanf(pFile, "%lf", &this->blobs_[0]->mutable_cpu_data()[i * channels_ + i]);
    }
    fclose(pFile);

    pFile = fopen("bilateral.par", "r");
    CHECK(pFile) << "The file 'bilateral.par' is not found. Please create it with initial bilateral kernel weights.";
    for (int i = 0; i < channels_; i++) {
      fscanf(pFile, "%lf", &this->blobs_[1]->mutable_cpu_data()[i * channels_ + i]);
    }
    fclose(pFile);
改为
    FILE * pFile;
    pFile = fopen("spatial.par", "r");
    if (pFile == NULL) {
	for (int i = 0; i < channels_; i++) {
    	    this->blobs_[0]->mutable_cpu_data()[i * channels_ + i] = spatial_filter_weight;
    	}
    }
    else {
        for (int i = 0; i < channels_; i++) {
            fscanf(pFile, "%lf", &this->blobs_[0]->mutable_cpu_data()[i * channels_ + i]);
        }
        fclose(pFile);
    }

    pFile = fopen("bilateral.par", "r");
    if (pFile == NULL) {
	for (int i = 0; i < channels_; i++) {
    	    this->blobs_[1]->mutable_cpu_data()[i * channels_ + i] = bilateral_filter_weight;
    	}
    }
    else {
        for (int i = 0; i < channels_; i++) {
            fscanf(pFile, "%lf", &this->blobs_[1]->mutable_cpu_data()[i * channels_ + i]);
        }
        fclose(pFile);
    }

4.caffe.proto中添加参数定义:
optional MultiStageMeanfieldParameter multi_stage_meanfield_param = 151;
以及
message MultiStageMeanfieldParameter {
  enum Mode {
    POTTS = 0;
  }
  optional Mode compatibility_mode = 1 [default = POTTS];
  optional float threshold = 2;
  
  required float theta_alpha = 3 [default = 10.];
  required float theta_beta = 4 [default = 10.];
  required float theta_gamma = 5 [default = 10.];
  
  required uint32 num_iterations = 6 [default = 1];
  optional float spatial_filter_weight = 7 [default = 1];
  optional float bilateral_filter_weight = 8 [default = 1];
  
  optional float forced_spatial_filter_weight = 9;
  optional float forced_bilateral_filter_weight = 10;
}

5.使用范例
layers { type: SPLIT name: 'splitting'
  bottom: 'pred_after_softmax' top: 'unary' top: 'Q0'
}
layers {
  name: "inference1_face"
  type: MULTI_STAGE_MEANFIELD
  bottom: "unary"
  bottom: "Q0"
  bottom: "data"
  top: "pred"  # not normalized, need softmax
  blobs_lr: 0.001
  blobs_lr: 0.001
  blobs_lr:0.01 #new parameter
  multi_stage_meanfield_param {
   num_iterations: 10
   compatibility_mode: POTTS
   threshold: 2
   theta_alpha: 160
   theta_beta: 3
   theta_gamma: 3
   spatial_filter_weight: 3
   bilateral_filter_weight: 5
  }
}
2017/01/15 17:02 pm. 魏震
